<html>
	<head>
		<meta charset="UTF-8" />
		<title>Stop the Toxic</title>>
		<style>html,body{height: 100%; margin: 0; background-color: black}</style>
		<script type="text/javascript" src="webgl-debug.js"></script>
		<script type="text/javascript" src='gl-matrix.js'></script>
	</head>
	<body>
		<canvas height="480" width="640" id="glFrame"></canvas>
		<div style="display:none" id="devNull"></div>
		<script type="module">
import {createPlayer, buildScene} from './render.js';
import SpriteSheet from './SpriteSheet.js';

const devNull = document.getElementById("devNull"); 
function placeCenter(node) {
	const mH = (window.innerWidth - node.width) / 2;
	const mV = (window.innerHeight - node.height) / 2;
	if(node.width > window.innerWidth || node.height > window.innerHeight) srceenToSmall();
	else canvasFitInSrceen();
	node.style.marginLeft = mH;
	node.style.marginTop = mV;
}
const canvas = document.getElementById('glFrame');
window.addEventListener("resize", function(){placeCenter(canvas);});
placeCenter(canvas);

var srceeDimensionMismatch = false;
function canvasFitInSrceen() {
	if (srceeDimensionMismatch) {
		console.debug('srceen now has valid size');
		srceeDimensionMismatch = false;
	}
}
function srceenToSmall() {
	if (!srceeDimensionMismatch) {
		alert('Viewport is to small to display game porperly.');
		srceeDimensionMismatch = true; 
	}
}

// setup dependencies
const dependencies = {
	['asm']: {loaded: null},
};

const matrices = {
	playerView: undefined,
	gameView: undefined
};

const loadCallBacks = [
	{dep: ['asm'], f: startGame}];

function LoadedDep(dep) {
	dependencies[dep].loaded = true;
	loadCallBacks.filter(function(el) {
		return  !!!el.dep  || (el.dep.includes(dep) && el.dep.every(function(d) {return dependencies[d].loaded;}));})
		.forEach(function(el) {el.f();});
}
const wasmFn = {};
function LodaedASM() {
	// function mapping
	// wasmFn.loadMatrix = Module.cwrap('loadMatrix', null, ['number']);	
	LoadedDep('asm');
}

const game = {};
window.initRenderLoop = function() {
	console.debug("init also start");
	game.scene = buildScene(gl);
	game.player = createPlayer(gl, new SpriteSheet(
		gl,
		document.getElementById('runner'),
		150, 146));
	const view = mat4.create();
	const proj = mat4.create();
	mat4.fromScaling(view, [0.3, 0.3, 1]);
	mat4.translate(view, view, [1, 0.5, 0]);
	
	const ratio = canvas.width / canvas.height;
	const heightInTiles = 5;
	mat4.ortho(proj, -ratio * heightInTiles, ratio * heightInTiles, heightInTiles, -heightInTiles, -1, 1);
	game.camera = {proj};

	game.player.SetViewMatrix(window.shared.player_mView.data);
	game.player.frame = window.shared.player_frameCount.data;
	window.requestAnimationFrame(update);
}

function startGame() {}

function update() {
	window.wasmFn.Update();
	game.scene.clear();
	game.player.draw(game);
	window.requestAnimationFrame(update);
}

// load gl context
const gl = WebGLDebugUtils.makeDebugContext(canvas.getContext('webgl'));
if(!!!gl) {
	alert('critial error: no webGl support, or data Corruption');
}

// setup refresh loop
var vendors = ['webkit', 'moz'];
for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
    window.cancelAnimationFrame =
      window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
}
if (!window.requestAnimationFrame)
    window.requestAnimationFrame = function(callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(currTime + timeToCall); },
          timeToCall);
        lastTime = currTime + timeToCall;
        return id;
};

if (!window.cancelAnimationFrame)
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
};

/* const resourcesToLoad = ['runner'];
resourcesToLoad.forEach(function(el) {
	document.getElementById(el).addEventListener('load', function() {
		console.log('nochmal: ' + el);
	});
});

export function LoadedRescource(_name) {
	resourcesToLoad = resourcesToLoad.filter(function(r) { return r !== _name;});
	if (resourcesToLoad.length === 0) {
		initRenderLoop();
	}
} */
// initRenderLoop();
		</script>
		<script type="text/javascript">
			class Shared {
				constructor(size, type) {
					this.size = size;
					this.type = type;
				}
				bind(ptr) {
					this.data = new this.type(Module.HEAP8.buffer, ptr, this.size);
				}
			};
			class INumber extends Shared {
				constructor(length) {
					super(length !== undefined ? length : 1, Uint32Array);
				}
				get(i) {
					return this.data[i !== undefined ? i : 0];
				}
			}
			class Matrix extends Shared {
				constructor() {
					super(16, Float32Array);
				}
				get() {
					return this.data;
				}
			}
			window.wasmFn = {};
			window.shared = {
				player_frameCount: new INumber(),
				player_mView: new  Matrix(),
			};
			function BindASM() {
				console.log("start binding");
				wasmFn.GetSharedPointer = Module.cwrap('GetSharedPointer', 'number', null);
				wasmFn.SharedPointerLength = Module.cwrap('SharedPointerLength', 'number', null);
				wasmFn.Update = Module.cwrap('Update', null, null);
				BindShared();
			}
			function BindShared() {
				const l = wasmFn.SharedPointerLength()
				const entrys = new Uint32Array(Module.HEAP8.buffer, wasmFn.GetSharedPointer(), l * 2);
				for(var i = 0; i < l; i++) {
					var name = "";
					var pStr = entrys[i * 2];
					const pP = entrys[i * 2 + 1];
					var c = 0;
					while(Module.HEAP8[pStr] !== 0) {
						const s = String.fromCharCode(Module.HEAP8[pStr])
						name += s;
						pStr++;
						if (c++ > 40) break;
					}
					shared[name].bind(Module.HEAPU32[pP / 4]); // TODO clean
				}
				console.log("finishd Binding");
				initRenderLoop();
			}
			// setup webasm
		var Module = {
			// onRuntimeInitialized: function(){BindASM();}	
		};
		</script>
		<script type="text/javascript" src="wasmLoader.js"></script>
		<div style="display:none">
			<img src="assets/runner.png" id="runner"/>
		</div>
	</body>
</html>